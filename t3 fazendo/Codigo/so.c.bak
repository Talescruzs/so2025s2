// so.c
// sistema operacional
// simulador de computador
// so25b

// ---------------------------------------------------------------------
// INCLUDES {{{1
// ---------------------------------------------------------------------

#include "so.h"
#include "cpu.h"
#include "dispositivos.h"
#include "err.h"
#include "irq.h"
#include "memoria.h"
#include "programa.h"
#include "tabpag.h"
#include "memoria_quadros.h"
#include "swap.h"
#include "relogio.h"

#include <stdlib.h>
#include <string.h>
#include <stdbool.h>


// ---------------------------------------------------------------------
// CONSTANTES E TIPOS {{{1
// ---------------------------------------------------------------------

// intervalo entre interrupções do relógio
#define INTERVALO_INTERRUPCAO 50   // em instruções executadas
#define MAX_PROCESSOS 4

#define QUANTUM 50
#define MEM_TAM 200 // tamanho da memória principal

enum EstadoProcesso {
    PRONTO,      /* 0 */
    EXECUTANDO,  /* 1 */
    BLOQUEADO,   /* 2 */
    MORTO       /* 3 */
};


// Não tem processos nem memória virtual, mas é preciso usar a paginação,
//   pelo menos para implementar relocação, já que os programas estão sendo
//   todos montados para serem executados no endereço 0 e o endereço 0
//   físico é usado pelo hardware nas interrupções.
// Os programas estão sendo carregados no início de um quadro, e usam quantos
//   quadros forem necessárias. Para isso a variável quadro_livre contém
//   o número do primeiro quadro da memória principal que ainda não foi usado.
//   Na carga do processo, a tabela de páginas (deveria ter uma por processo,
//   mas não tem processo) é alterada para que o endereço virtual 0 resulte
//   no quadro onde o programa foi carregado. Com isso, o programa carregado
//   é acessível, mas o acesso ao anterior é perdido.

typedef struct processo {
    int pid;                    // identificador do processo
    int ppid;                   // identificador do processo pai
    int terminal;               // terminal associado ao processo (se aplicável)
    enum EstadoProcesso estado; // estado do processo (pronto, executando, bloqueado)
    int regA, regX, regPC, regERRO; // registradores salvos do processo
    int quantum;                // quantum restante (se/quando usar escalonamento por tempo)
    int esperando_pid;          // PID do processo que está esperando (SO_ESPERA_PROC)
    int esperando_dispositivo;  // dispositivo de E/S que está aguardando (se aplicável)
    int memoria_base;           // endereço base da memória do processo (se/quando implementar)
    int memoria_limite;         // limite superior da memória do processo (se/quando implementar)
    struct processo *prox;      // ponteiro para próximo processo na fila (lista encadeada)
    float prioridade;

    // primeiro quadro da memória que está livre (quadros anteriores estão ocupados)
    // t3: com memória virtual, o controle de memória livre e ocupada deve ser mais
    //     completo que isso
    int quadro_livre;
    // uma tabela de páginas para poder usar a MMU
    // t3: com processos, não tem esta tabela global, tem que ter uma para
    //     cada processo
    tabpag_t *tabpag;
    
    // Campos para memória virtual
    int swap_inicio;            // endereço inicial na memória secundária
    int n_paginas;              // número de páginas do processo
    int tempo_desbloqueio;      // tempo até o qual o processo deve ficar bloqueado (I/O disco)
    int n_faltas_pagina;        // contador de faltas de página
    unsigned int lru_counter[100]; // contador LRU para cada página (máximo 100 páginas)
} processo;

processo *processo_cria(int id, int pc, int max_quantum) {
    processo *p = (processo*)malloc(sizeof(processo));
    if (p == NULL) return NULL;
    p->pid = id;
    p->regPC = pc;
    p->estado = PRONTO;
    p->quantum = max_quantum;
    p->prioridade = 0.5;
    p->tabpag = tabpag_cria();
    p->swap_inicio = -1;
    p->n_paginas = 0;
    p->tempo_desbloqueio = 0;
    p->n_faltas_pagina = 0;
    // Inicializa contadores LRU
    for (int i = 0; i < 100; i++) {
        p->lru_counter[i] = 0;
    }
    return p;
}

// t3: a interface de algumas funções que manipulam memória teve que ser alterada,
//   para incluir o processo ao qual elas se referem. Para isso, é necessário um
//   tipo de dados para identificar um processo. Neste código, não tem processos
//   implementados, e não tem um tipo para isso. Foi usado o tipo int.
//   É necessário também um valor para representar um processo inexistente.
//   Foi usado o valor -1. Altere para o seu tipo, ou substitua os usos de
//   processo_t e NENHUM_PROCESSO para o seu tipo.
//   ALGUM_PROCESSO serve para representar um processo que não é NENHUM. Só tem
//   algum sentido enquanto não tem implementação de processos.
#define NENHUM_PROCESSO -1
#define ALGUM_PROCESSO 0

#define ESC_TIPO ESC_PRIORIDADE
#define MEM_Q_TIPO MEM_Q_SC



typedef struct so_t {
  cpu_t *cpu;
  mem_t *mem;
  mmu_t *mmu;
  es_t *es;
  console_t *console;
  bool erro_interno;

  int regA, regX, regPC, regERRO, regComplemento; // cópia do estado da CPU

  int processo_corrente; // índice do processo corrente na tabela de processos

  processo *tabela_processos;

  // Fila circular de processos prontos
  int fila_prontos[MAX_PROCESSOS];
  int inicio_fila;
  int fim_fila;

  // pro segundo escalonador
  int estado;
  float prioridade;
  int contador_quantum;
  int quantum;

  // alocador global simples de quadros (novo)
  mem_quadros_t *quadros;
  int next_quadro_livre;

  int quadro_livre_pri;
  int quadro_livre_sec;

  // ponteiro para função de escalonamento (definida em runtime)
  void (*escalonador)(struct so_t *self);

  // Memória secundária e relógio
  swap_t *swap;
  relogio_t *relogio;

} so_t;




// struct so_t {
//   cpu_t *cpu;
//   mem_t *mem;
//   mmu_t *mmu;
//   es_t *es;
//   console_t *console;
//   bool erro_interno;

//   int regA, regX, regPC, regERRO, regComplemento; // cópia do estado da CPU
//   // t2: tabela de processos, processo corrente, pendências, etc

//   int processo_corrente; // índice do processo corrente na tabela de processos

//   processo *tabela_processos;

//   // Fila circular de processos prontos
//   int fila_prontos[MAX_PROCESSOS];
//   int inicio_fila;
//   int fim_fila;

//   // pro segundo escalonador
//   int estado;
//   float prioridade;
//   int contador_quantum;
//   int quantum;

//   // ponteiro para função de escalonamento (definida em runtime)
//   void (*escalonador)(struct so_t *self);

// };

// protótipos de escalonadores
static void so_escalona(so_t *self);
static void so_escalona2(so_t *self);

// API para escolher escalonador em runtime
void so_define_escalonador(so_t *self, int id);

static void insere_fila_prontos(so_t *self, int idx_processo);
static int remove_fila_prontos(so_t *self);

// função de tratamento de interrupção (entrada no SO)
static int so_trata_interrupcao(void *argC, int reg_A);

// funções auxiliares
// no t3, foi adicionado o 'processo' aos argumentos dessas funções 
// carrega o programa contido no arquivo para memória virtual de um processo
// retorna o endereço virtual inicial de execução
static int so_carrega_programa(so_t *self, int processo,
                               char *nome_do_executavel);
// copia para str da memória do processo, até copiar um 0 (retorna true) ou tam bytes
static bool so_copia_str_do_processo(so_t *self, int tam, char str[tam],
                                     int end_virt, int processo);


// ---------------------------------------------------------------------
// CRIAÇÃO {{{1
// ---------------------------------------------------------------------

so_t *so_cria(cpu_t *cpu, mem_t *mem, mmu_t *mmu,
              es_t *es, console_t *console, relogio_t *relogio)
{
  console_printf("criando  ");
  so_t *self = malloc(sizeof(*self));
  if (self == NULL) return NULL;

  self->inicio_fila = 0;
  self->fim_fila = 0;
  self->processo_corrente = 0;
  self->quantum = QUANTUM;  // define o quantum inicial
  self->contador_quantum = 0;
  self->next_quadro_livre = 0; 

  /* aloca e inicializa a tabela de processos uma única vez */
  self->tabela_processos = malloc(sizeof(processo) * MAX_PROCESSOS);
  if (self->tabela_processos == NULL) {
      free(self);
      return NULL;
  }
  memset(self->tabela_processos, 0, sizeof(processo) * MAX_PROCESSOS);

  self->cpu = cpu;
  self->mem = mem;
  self->mmu = mmu;
  self->es = es;
  self->console = console;
  self->erro_interno = false;
  self->relogio = relogio;

  // escalonador padrão: round-robin
  self->escalonador = so_escalona;

  // quando a CPU executar uma instrução CHAMAC, deve chamar a função
  //   so_trata_interrupcao, com primeiro argumento um ptr para o SO
  cpu_define_chamaC(self->cpu, so_trata_interrupcao, self);

  // inicializa a tabela de páginas por processo
  for (int i = 0; i < MAX_PROCESSOS; i++) {
      self->tabela_processos[i].estado = MORTO; // inicializa todos os processos como mortos
      self->tabela_processos[i].tabpag  = tabpag_cria();
      self->tabela_processos[i].swap_inicio = -1;
      self->tabela_processos[i].n_paginas = 0;
      self->tabela_processos[i].tempo_desbloqueio = 0;
      self->tabela_processos[i].n_faltas_pagina = 0;
      for (int j = 0; j < 100; j++) {
          self->tabela_processos[i].lru_counter[j] = 0;
      }
  }

  self->processo_corrente = 0; // nenhum processo está executando

  self->quadro_livre_pri = 99 / TAM_PAGINA + 1;
  self->quadro_livre_sec = 0;

  self->quadros = mem_quadros_cria(MEM_TAM / TAM_PAGINA, 99 / TAM_PAGINA + 1, MEM_Q_TIPO);
  
  // Cria memória secundária (swap) - tamanho generoso para todos os processos
  self->swap = swap_cria(1000, TAM_PAGINA, relogio);

  console_printf("criei   ");

  return self;
}
void so_destroi(so_t *self)
{
  cpu_define_chamaC(self->cpu, NULL, NULL);
  
  // Imprime estatísticas antes de destruir
  console_printf("\n========== ESTATÍSTICAS DO SISTEMA ==========\n");
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].pid > 0) {
      console_printf("Processo PID=%d: %d faltas de página\n",
                     self->tabela_processos[i].pid,
                     self->tabela_processos[i].n_faltas_pagina);
    }
  }
  console_printf("Tamanho da memória principal: %d palavras (%d páginas)\n",
                 mem_tam(self->mem), mem_tam(self->mem) / TAM_PAGINA);
  console_printf("Tamanho de página: %d palavras\n", TAM_PAGINA);
  console_printf("=============================================\n");
  
  // Libera memória
  if (self->swap) swap_destroi(self->swap);
  if (self->quadros) free(self->quadros);
  
  free(self);
}




// ---------------------------------------------------------------------
// TRATAMENTO DE INTERRUPÇÃO {{{1
// ---------------------------------------------------------------------

// funções auxiliares para o tratamento de interrupção
static void so_salva_estado_da_cpu(so_t *self);
static void so_trata_irq(so_t *self, int irq);
static void so_trata_pendencias(so_t *self);
static void so_escalona(so_t *self);
static int so_despacha(so_t *self);

// função a ser chamada pela CPU quando executa a instrução CHAMAC, no tratador de
//   interrupção em assembly
// essa é a única forma de entrada no SO depois da inicialização
// na inicialização do SO, a CPU foi programada para chamar esta função para executar
//   a instrução CHAMAC
// a instrução CHAMAC só deve ser executada pelo tratador de interrupção
//
// o primeiro argumento é um ponteiro para o SO, o segundo é a identificação
//   da interrupção
// o valor retornado por esta função é colocado no registrador A, e pode ser
//   testado pelo código que está após o CHAMAC. No tratador de interrupção em
//   assembly esse valor é usado para decidir se a CPU deve retornar da interrupção
//   (e executar o código de usuário) ou executar PARA e ficar suspensa até receber
//   outra interrupção



static int so_trata_interrupcao(void *argC, int reg_A)
{
  console_printf("interrompido   ");
  so_t *self = argC;
  irq_t irq = reg_A;
  
  // esse print polui bastante, recomendo tirar quando estiver com mais confiança
  console_printf("SO: recebi IRQ %d (%s)", irq, irq_nome(irq));
  if(irq == 1){
    console_printf("A = %d, X = %d, PC = %d", self->regA, self->regX, self->regPC);

  }
  // salva o estado da cpu no descritor do processo que foi interrompido
  so_salva_estado_da_cpu(self);
  // faz o atendimento da interrupção
  so_trata_irq(self, irq);
  // faz o processamento independente da interrupção
  so_trata_pendencias(self);
  // escolhe o próximo processo a executar
  if (self->escalonador) self->escalonador(self);

  if (self->tabela_processos[0].estado != MORTO) {
      int retorno = so_despacha(self);
      console_printf("RETORNO DESPACHA: %d", retorno);
      return retorno;
  }
  return 1;
}


// ANTIGO

// static int so_trata_interrupcao(void *argC, int reg_A)
// {
//   console_printf("interrompido   ");
//   so_t *self = argC;
//   irq_t irq = reg_A;
  
//   // esse print polui bastante, recomendo tirar quando estiver com mais confiança
//   console_printf("SO: recebi IRQ %d (%s)", irq, irq_nome(irq));
//   // salva o estado da cpu no descritor do processo que foi interrompido
//   so_salva_estado_da_cpu(self);
//   // faz o atendimento da interrupção
//   so_trata_irq(self, irq);
//   // faz o processamento independente da interrupção
//   so_trata_pendencias(self);
//   // escolhe o próximo processo a executar
//   if (self->escalonador) self->escalonador(self);
//   mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag); // limpa tabela de páginas na MMU
//   // recupera o estado do processo escolhido
//   return so_despacha(self);
// }

  
// static void so_salva_estado_da_cpu(so_t *self)
// {
//   // t2: salva os registradores que compõem o estado da cpu no descritor do
//   //   processo corrente. os valores dos registradores foram colocados pela
//   //   CPU na memória, nos endereços CPU_END_PC etc. O registrador X foi salvo
//   //   pelo tratador de interrupção (ver trata_irq.asm) no endereço 59
//   // se não houver processo corrente, não faz nada
//   console_printf("salvando estado da CPU   ");
//   if (self->processo_corrente < 0 || self->processo_corrente >= MAX_PROCESSOS) {
//     console_printf("SO: processo_corrente inválido em salva_estado");
//     self->erro_interno = true;
//     return;
//   }
  
  
//   if (mmu_le(self->mmu, CPU_END_A, &self->tabela_processos[self->processo_corrente].regA, supervisor) != ERR_OK
//       || mmu_le(self->mmu, CPU_END_PC, &self->tabela_processos[self->processo_corrente].regPC, supervisor) != ERR_OK
//       || mmu_le(self->mmu, CPU_END_erro, &self->tabela_processos[self->processo_corrente].regERRO, supervisor) != ERR_OK
//       || mmu_le(self->mmu, 59, &self->tabela_processos[self->processo_corrente].regX, supervisor) != ERR_OK) {
//     console_printf("SO: erro na leitura dos registradores");
//     self->erro_interno = true;
//   }
//   console_printf("A = %d, X = %d, PC = %d", self->regA, self->regX, self->regPC);

// }

static void so_salva_estado_da_cpu(so_t *self)
{
  // t1: salva os registradores que compõem o estado da cpu no descritor do
  //   processo corrente. os valores dos registradores foram colocados pela
  //   CPU na memória, nos endereços IRQ_END_*
  // se não houver processo corrente, não faz nada
  if (self->tabela_processos[self->processo_corrente].estado == MORTO) return;
  if (self->tabela_processos[self->processo_corrente].estado != EXECUTANDO) return;
  int pc, a, x, err;
  mem_le(self->mem, CPU_END_PC, &pc);
  mem_le(self->mem, CPU_END_A, &a);
  mem_le(self->mem, 59, &x);
  mem_le(self->mem, CPU_END_erro, &err);

  self->tabela_processos[self->processo_corrente].regA = a;
  self->tabela_processos[self->processo_corrente].regX = x;
  self->tabela_processos[self->processo_corrente].regPC = pc;
  self->tabela_processos[self->processo_corrente].regERRO = err;
}


static void so_trata_pendencias(so_t *self)
{
  console_printf("tratando pendências   ");
  
  // Obter tempo atual do relógio
  int tempo_atual = 0;
  relogio_leitura(self->relogio, 0, &tempo_atual);
  
    for (int i = 0; i < MAX_PROCESSOS; i++){
      processo *proc = &self->tabela_processos[i];
      // ex: desbloq processo que espera dispositivo pronto
      if (proc->estado == BLOQUEADO){
        // Desbloqueia processo que terminou espera por disco
        if (proc->tempo_desbloqueio > 0 && tempo_atual >= proc->tempo_desbloqueio) {
            proc->estado = PRONTO;
            proc->tempo_desbloqueio = 0;
            insere_fila_prontos(self, i);
            console_printf("SO: processo %d desbloqueado (disco)", proc->pid);
        }
        
        if (proc->esperando_dispositivo >= 0) {
          int disp = proc->esperando_dispositivo;
          int estado_disp = 0;
          if (es_le(self->es, disp, &estado_disp) == ERR_OK && estado_disp != 0) {
                    proc->estado = PRONTO;
                    proc->esperando_dispositivo = -1;
                    proc->quantum = 0;
                    insere_fila_prontos(self, i);  // i é o índice do processo desbloqueado

                }
        }

        if (proc->esperando_pid > 0){
          bool terminou = true;
          for (int j = 0; j < MAX_PROCESSOS; j++){
            if (self->tabela_processos[j].pid == proc->esperando_pid && self->tabela_processos[j].estado != MORTO) {
              terminou = false;
              break;
            }
          }
          if (terminou) {
            proc->estado = PRONTO;
            proc->esperando_pid = -1;
            proc->quantum = 0;
            insere_fila_prontos(self, i);  // i é o índice do processo desbloqueado

          }
        }
      }
    }
}

static void so_escalona(so_t *self)
{

    int atual = self->processo_corrente;
    int proximo = -1;
    int prontos = 0;
    console_printf("escalonando (RR) %d", self->processo_corrente);


    for (int i = 0; i < MAX_PROCESSOS; i++) {
        if (self->tabela_processos[i].estado == PRONTO) {
            prontos++;
        }
    }

    if (atual >= 0 && atual < MAX_PROCESSOS &&
        self->tabela_processos[atual].estado == EXECUTANDO &&
        prontos > 0) {
        self->tabela_processos[atual].estado = PRONTO;
        insere_fila_prontos(self, atual);
    }

    // pega próximo da fila se houver
    int idx_fila = remove_fila_prontos(self);
    if (idx_fila != -1 && self->tabela_processos[idx_fila].estado == PRONTO) {
        proximo = idx_fila;
    } else {
        // fallback: busca sequencial
        for (int i = 1; i <= MAX_PROCESSOS; i++) {
            int idx = (atual + i) % MAX_PROCESSOS;
            if (self->tabela_processos[idx].estado == PRONTO) {
                proximo = idx;
                break;
            }
        }
    }

    if (proximo != -1) {
        self->tabela_processos[proximo].estado = EXECUTANDO;
        self->processo_corrente = proximo;
        self->contador_quantum = self->quantum;
    } else if (atual >= 0 && atual < MAX_PROCESSOS &&
               self->tabela_processos[atual].estado != BLOQUEADO &&
               self->tabela_processos[atual].estado != MORTO) {
        self->tabela_processos[atual].estado = EXECUTANDO;
        self->processo_corrente = atual;
    } else {
        self->processo_corrente = -1;
    }


}

static void so_escalona2(so_t *self)
{
    console_printf("escalonando %d", self->processo_corrente);

    int atual = self->processo_corrente;
    int proximo = -1;
    int prontos = 0;

    // Contar processos PRONTOS
    for (int i = 0; i < MAX_PROCESSOS; i++) {
        if (self->tabela_processos[i].estado == PRONTO) {
            prontos++;
        }
    }

    // Se processo atual está EXECUTANDO e há outro processo PRONTO,
    // recalcula prioridade do atual (quantum estourado ou bloqueio deve ser tratado externamente)
    if (atual >= 0 && atual < MAX_PROCESSOS &&
        self->tabela_processos[atual].estado == EXECUTANDO &&
        prontos > 0) {

        // Obtém t_exec e tempo de quantum (deve estar armazenado em algum lugar)
        int t_quantum = self->quantum;
        int t_exec = t_quantum - self->contador_quantum; // contador_quantum é decrementado a cada interrupção

        float prio_antiga = self->tabela_processos[atual].prioridade;
        float prio_nova = (prio_antiga + ((float)t_exec / t_quantum)) / 2.0f;

        self->tabela_processos[atual].prioridade = prio_nova;
        self->tabela_processos[atual].estado = PRONTO;

        // Insere o processo atual no fim da fila de prontos
        insere_fila_prontos(self, atual);
    }

    // Escolhe o próximo processo PRONTO com menor valor de prioridade (maior prioridade real)
    float menor_prio = 1000.0f; // valor grande inicial
    for (int i = 0; i < MAX_PROCESSOS; i++) {
        if (self->tabela_processos[i].estado == PRONTO) {
            float prio = self->tabela_processos[i].prioridade;
            if (prio < menor_prio) {
                menor_prio = prio;
                proximo = i;
            }
        }
    }

    if (proximo != -1) {
        self->tabela_processos[proximo].estado = EXECUTANDO;
        self->processo_corrente = proximo;
        self->contador_quantum = self->quantum; // reseta contador do quantum para novo processo
    } else if (atual >= 0 && atual < MAX_PROCESSOS &&
               self->tabela_processos[atual].estado != BLOQUEADO &&
               self->tabela_processos[atual].estado != MORTO) {
        // Mantém processo atual EXECUTANDO se não há outro PRONTO
        self->tabela_processos[atual].estado = EXECUTANDO;
        self->processo_corrente = atual;
    } else {
        // Nenhum processo PRONTO ou EXECUTANDO disponível
        self->processo_corrente = -1;
    }
}

static int so_despacha(so_t *self)
{
  // t2: se houver processo corrente, coloca o estado desse processo onde ele
  //   será recuperado pela CPU (em CPU_END_PC etc. e 59) e retorna 0,
  //   senão retorna 1
  // o valor retornado será o valor de retorno de CHAMAC, e será colocado no 
  //   registrador A para o tratador de interrupção (ver trata_irq.asm).
  
  if (self->processo_corrente < 0 || self->processo_corrente >= MAX_PROCESSOS) {
    return 1;
  }
  
  if (self->tabela_processos[self->processo_corrente].estado == MORTO) {
    return 1;
  }
  
  // Configura a MMU com a tabela de páginas do processo corrente
  mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
  
  if (mem_escreve(self->mem, CPU_END_A, self->tabela_processos[self->processo_corrente].regA) != ERR_OK
      || mem_escreve(self->mem, CPU_END_PC, self->tabela_processos[self->processo_corrente].regPC) != ERR_OK
      || mem_escreve(self->mem, CPU_END_erro, self->tabela_processos[self->processo_corrente].regERRO) != ERR_OK
      || mem_escreve(self->mem, 59, self->tabela_processos[self->processo_corrente].regX)) {
    console_printf("SO: erro na escrita dos registradores");
    self->erro_interno = true;
  }
  
  if (self->erro_interno) return 1;
  else return 0;
}

// static int so_despacha(so_t *self)
// {
//   // t1: se houver processo corrente, coloca o estado desse processo onde ele
//   //   será recuperado pela CPU (em IRQ_END_*) e retorna 0, senão retorna 1
//   // o valor retornado será o valor de retorno de CHAMAC
//   // passa o processador para modo usuário
//   mem_escreve(self->mem, CPU_END_erro, ERR_OK);
//   if (self->erro_interno) return 1;
//   if (self->tabela_processos[self->processo_corrente].estado == MORTO) return 1;
//   if (self->tabela_processos[self->processo_corrente].estado != EXECUTANDO) return 1;
//   int pc, a, x, comp;
//   pc = self->tabela_processos[self->processo_corrente].regPC;
//   a = self->tabela_processos[self->processo_corrente].regA;
//   x = self->tabela_processos[self->processo_corrente].regX;
//   comp = self->tabela_processos[self->processo_corrente].regERRO;
//   mem_escreve(self->mem, CPU_END_PC, pc);
//   mem_escreve(self->mem, CPU_END_A, a);
//   mem_escreve(self->mem, 59, x);
//   mem_escreve(self->mem, CPU_END_complemento, comp);
//   mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
//   mem_escreve(self->mem, CPU_END_erro, ERR_OK);
//   int inst;
//   mmu_le(self->mmu, pc+1, &inst, usuario);
//   console_printf("PC: %d, INST: %d, processo: %d", pc, inst, self->processo_corrente);
//   console_printf("Página: %d", pc/TAM_PAGINA);
//   return 0;
// }

// ---------------------------------------------------------------------
// TRATAMENTO DE UMA IRQ {{{1
// ---------------------------------------------------------------------

// funções auxiliares para tratar cada tipo de interrupção
static void so_trata_reset(so_t *self);
static void so_trata_irq_chamada_sistema(so_t *self);
static void so_trata_irq_err_cpu(so_t *self);
static void so_trata_irq_relogio(so_t *self);
static void so_trata_irq_desconhecida(so_t *self, int irq);

static void so_trata_irq(so_t *self, int irq)
{ 
  console_printf("tratando IRQ   ");
  // verifica o tipo de interrupção que está acontecendo, e atende de acordo
  switch (irq) {
    case IRQ_RESET:
      so_trata_reset(self);
      break;
    case IRQ_SISTEMA:
      so_trata_irq_chamada_sistema(self);
      break;
    case IRQ_ERR_CPU:
      so_trata_irq_err_cpu(self);
      break;
    case IRQ_RELOGIO:
      so_trata_irq_relogio(self);
      break;
    default:
      so_trata_irq_desconhecida(self, irq);
  }
}

// chamada uma única vez, quando a CPU inicializa
static void so_trata_reset(so_t *self)
{
  console_printf("recebi RESET   ");
  // coloca o tratador de interrupção na memória
  // quando a CPU aceita uma interrupção, passa para modo supervisor,
  //   salva seu estado à partir do endereço CPU_END_PC, e desvia para o
  //   endereço CPU_END_TRATADOR
  // colocamos no endereço CPU_END_TRATADOR o programa de tratamento
  //   de interrupção (escrito em asm). esse programa deve conter a
  //   instrução CHAMAC, que vai chamar so_trata_interrupcao (como
  //   foi definido na inicialização do SO)
  int ender = so_carrega_programa(self, NENHUM_PROCESSO, "trata_int.maq");
  if (ender != CPU_END_TRATADOR) {
    console_printf("SO: problema na carga do programa de tratamento de interrupção");
    self->erro_interno = true;
  }
  
  // programa o relógio para gerar uma interrupção após INTERVALO_INTERRUPCAO
  if (es_escreve(self->es, D_RELOGIO_TIMER, INTERVALO_INTERRUPCAO) != ERR_OK) {
    console_printf("SO: problema na programação do timer");
    self->erro_interno = true;
  }

  // define o primeiro quadro livre de memória como o seguinte àquele que
  //   contém o endereço final da memória protegida (que não podem ser usadas
  //   por programas de usuário)
  // t3: o controle de memória livre deve ser mais aprimorado que isso
  
  // teste

    self->next_quadro_livre = CPU_END_FIM_PROT / TAM_PAGINA + 1;
  // opcional: inicializar também os quadro_livre de cada processo como 0
  for (int i = 0; i < MAX_PROCESSOS; i++) {
      self->tabela_processos[i].quadro_livre = 0;
  }

  
  //ANTIGO
  // self->tabela_processos[self->processo_corrente].quadro_livre = CPU_END_FIM_PROT / TAM_PAGINA + 1;

  // t2: deveria criar um processo para o init, e inicializar o estado do
  //   processador para esse processo com os registradores zerados, exceto
  //   o PC e o modo.
  // como não tem suporte a processos, está carregando os valores dos
  //   registradores diretamente no estado da CPU mantido pelo SO; daí vai
  //   copiar para o início da memória pelo despachante, de onde a CPU vai
  //   carregar para os seus registradores quando executar a instrução RETI
  //   em bios.asm (que é onde está a instrução CHAMAC que causou a execução
  //   deste código
  
  // Inicializa o processo 0 ANTES de carregar o programa
  self->processo_corrente = 0;
  self->tabela_processos[0].pid = 1;
  self->tabela_processos[0].ppid = 0;
  self->tabela_processos[0].estado = EXECUTANDO;
  
  ender = so_carrega_programa(self, self->processo_corrente, "init.maq");
  if (ender == -1) {
    console_printf("SO: problema na carga do programa inicial, ender = %d", ender);
    self->erro_interno = true;
    return;
  }
  
  self->tabela_processos[0].regA = 0;
  self->tabela_processos[0].regX = 0;
  self->tabela_processos[0].regERRO = 0;
  self->tabela_processos[0].regPC = ender;
  self->tabela_processos[0].quantum = self->quantum;  // inicializa com quantum completo
  self->tabela_processos[0].esperando_pid = -1;
  self->tabela_processos[0].esperando_dispositivo = -1;
  self->tabela_processos[0].memoria_base = 0;
  self->tabela_processos[0].memoria_limite = 0;
  self->tabela_processos[0].terminal = D_TERM_A_TELA;
  self->tabela_processos[0].prioridade = 0.0f;  // prioridade inicial máxima
  self->tabela_processos[0].tempo_desbloqueio = 0;
  self->tabela_processos[0].n_faltas_pagina = 0;

  // altera o PC para o endereço de carga
  self->regPC = ender; // deveria ser no processo
}

// static void so_trata_irq_reset(so_t *self)
// {
//   console_printf("recebi RESET   ");
//   // coloca o tratador de interrupção na memória
//   // quando a CPU aceita uma interrupção, passa para modo supervisor,
//   //   salva seu estado à partir do endereço CPU_END_PC, e desvia para o
//   //   endereço CPU_END_TRATADOR
//   // colocamos no endereço CPU_END_TRATADOR o programa de tratamento
//   //   de interrupção (escrito em asm). esse programa deve conter a
//   //   instrução CHAMAC, que vai chamar so_trata_interrupcao (como
//   //   foi definido na inicialização do SO)

//   int ender = so_carrega_programa(self, NENHUM_PROCESSO, "trata_int.maq");
//   if (ender != CPU_END_TRATADOR) {
//     console_printf("SO: problema na carga do programa de tratamento de interrupção");
//     self->erro_interno = true;
//   }
  
//   // programa o relógio para gerar uma interrupção após INTERVALO_INTERRUPCAO
//   if (es_escreve(self->es, D_RELOGIO_TIMER, INTERVALO_INTERRUPCAO) != ERR_OK) {
//     console_printf("SO: problema na programação do timer");
//     self->erro_interno = true;
//   }

//   processo *processo = processo_cria(self->processo_corrente + 1, 0, QUANTUM); // deveria inicializar um processo...
//   ender = so_carrega_programa(self, processo->pid, "init.maq");
//   if (ender != 0) {
//     console_printf("SO: problema na carga do programa inicial");
//     self->erro_interno = true;
//     return;
//   }
//   for (int i = 0; i < MAX_PROCESSOS; i++) {
//           if (self->tabela_processos[i].estado == MORTO) {
//               self->tabela_processos[i] = *processo;
//               self->fim_fila++;
//               break;
//           }
//       }
//   self->tabela_processos[self->processo_corrente] = *processo;

//   // altera o PC para o endereço de carga (deve ter sido o endereço virtual 0)
//   mem_escreve(self->mem, CPU_END_PC, self->tabela_processos[self->processo_corrente].regPC);
//   // passa o processador para modo usuário
//   mem_escreve(self->mem, CPU_END_erro, ERR_OK);
// }

// funções auxiliares para tratamento de falta de página

// Aloca um quadro livre ou libera um ocupado usando substituição de páginas
static int so_aloca_quadro(so_t *self)
{
  // Procura por um quadro livre
  int quadro = mem_quadros_tem_livre(self->quadros);
  
  if (quadro >= 0) {
    console_printf("SO: quadro %d alocado (livre)", quadro);
    return quadro;
  }
  
  // Não há quadros livres - precisa substituir uma página
  console_printf("SO: sem quadros livres, substituindo página (FIFO)");
  
  // Obtém o quadro a ser liberado (FIFO)
  quadro = mem_quadros_libera_quadro_fifo(self->quadros);
  
  // Obtém informações sobre a página que está sendo substituída
  int dono_pid = mem_quadros_pega_dono(self->quadros, quadro);
  int pagina_vitima = mem_quadros_pega_pagina(self->quadros, quadro);
  
  console_printf("SO: substituindo pag=%d proc=%d quadro=%d", pagina_vitima, dono_pid, quadro);
  
  // Encontra o processo dono
  int idx_dono = -1;
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].pid == dono_pid) {
      idx_dono = i;
      break;
    }
  }
  
  if (idx_dono < 0) {
    console_printf("SO: erro - processo dono %d não encontrado", dono_pid);
    return -1;
  }
  
  // Verifica se a página foi alterada
  bool alterada = tabpag_bit_alteracao(self->tabela_processos[idx_dono].tabpag, pagina_vitima);
  
  if (alterada) {
    console_printf("SO: página alterada, salvando na swap");
    
    // Salva página na swap
    int end_swap = swap_endereco_pagina(self->swap, dono_pid, pagina_vitima);
    if (end_swap < 0) {
      console_printf("SO: erro ao obter endereço na swap");
      return -1;
    }
    
    // Lê dados da página da memória principal
    int dados[TAM_PAGINA];
    int end_fis = quadro * TAM_PAGINA;
    for (int i = 0; i < TAM_PAGINA; i++) {
      mem_le(self->mem, end_fis + i, &dados[i]);
    }
    
    // Escreve na swap
    int tempo_bloqueio;
    swap_escreve_pagina(self->swap, end_swap, dados, TAM_PAGINA, &tempo_bloqueio);
    
    // Bloqueia o processo dono se for diferente do corrente
    if (idx_dono != self->processo_corrente && self->tabela_processos[idx_dono].estado != MORTO) {
      self->tabela_processos[idx_dono].estado = BLOQUEADO;
      self->tabela_processos[idx_dono].tempo_desbloqueio = tempo_bloqueio;
    }
  }
  
  // Invalida a página na tabela do processo dono
  tabpag_invalida_pagina(self->tabela_processos[idx_dono].tabpag, pagina_vitima);
  
  return quadro;
}

// Trata uma falta de página
static void so_trata_falta_pagina(so_t *self, int idx_proc, int pagina)
{
  console_printf("SO: tratando falta de página %d do processo idx=%d", pagina, idx_proc);
  
  processo *proc = &self->tabela_processos[idx_proc];
  
  // Aloca um quadro (pode fazer substituição)
  int quadro = so_aloca_quadro(self);
  if (quadro < 0) {
    console_printf("SO: erro ao alocar quadro");
    proc->estado = MORTO;
    return;
  }
  
  // Obtém endereço da página na swap
  int end_swap = swap_endereco_pagina(self->swap, proc->pid, pagina);
  if (end_swap < 0) {
    console_printf("SO: erro ao obter endereço da página na swap");
    proc->estado = MORTO;
    return;
  }
  
  // Lê a página da swap
  int dados[TAM_PAGINA];
  int tempo_bloqueio;
  if (swap_le_pagina(self->swap, end_swap, dados, TAM_PAGINA, &tempo_bloqueio) != ERR_OK) {
    console_printf("SO: erro ao ler página da swap");
    proc->estado = MORTO;
    return;
  }
  
  // Escreve os dados no quadro da memória principal
  int end_fis = quadro * TAM_PAGINA;
  for (int i = 0; i < TAM_PAGINA; i++) {
    mem_escreve(self->mem, end_fis + i, dados[i]);
  }
  
  // Atualiza a tabela de páginas
  tabpag_define_quadro(proc->tabpag, pagina, quadro);
  
  // Registra o quadro como ocupado
  mem_quadros_muda_estado(self->quadros, quadro, false, proc->pid, pagina);
  
  // Bloqueia o processo até que a operação de disco termine
  proc->estado = BLOQUEADO;
  proc->tempo_desbloqueio = tempo_bloqueio;
  
  console_printf("SO: página %d mapeada no quadro %d, processo bloqueado até %d", 
                 pagina, quadro, tempo_bloqueio);
}

// interrupção gerada quando a CPU identifica um erro

static void so_trata_irq_err_cpu(so_t *self)
{
  console_printf("erro na CPU   ");

  int idx = self->processo_corrente;
  if (idx < 0 || idx >= MAX_PROCESSOS) {
    console_printf("SO: não há processo corrente válido ao tratar erro da CPU (idx=%d)\n", idx);
    return;
  }

  err_t err = self->tabela_processos[idx].regERRO;
  int pid = self->tabela_processos[idx].pid;
  int pc  = self->tabela_processos[idx].regPC;
  
  // Lê o complemento da CPU para obter o endereço que causou a falha
  mem_le(self->mem, CPU_END_complemento, &self->regComplemento);
  
  console_printf("SO: IRQ de ERRO na CPU: %s (complemento=%d) proc_idx=%d pid=%d pc=%d",
                 err_nome(err), self->regComplemento, idx, pid, pc);

  // Trata falta de página
  if (err == ERR_PAG_AUSENTE) {
    int end_virt = self->regComplemento;
    int pagina = end_virt / TAM_PAGINA;
    
    // Verifica se o endereço é válido para o processo
    if (pagina < 0 || pagina >= self->tabela_processos[idx].n_paginas) {
      console_printf("SO: acesso inválido à página %d (processo tem %d páginas)",
                     pagina, self->tabela_processos[idx].n_paginas);
      // Segmentation fault - mata o processo
      self->tabela_processos[idx].estado = MORTO;
      
      // Libera recursos
      if (self->tabela_processos[idx].swap_inicio >= 0) {
        swap_libera_processo(self->swap, pid);
      }
      mem_quadros_remove_processo(self->quadros, pid);
      
      // Desbloqueia processos esperando
      for (int i = 0; i < MAX_PROCESSOS; i++) {
        if (self->tabela_processos[i].estado == BLOQUEADO &&
            self->tabela_processos[i].esperando_pid == pid) {
          self->tabela_processos[i].estado = PRONTO;
          self->tabela_processos[i].esperando_pid = -1;
          self->tabela_processos[i].regA = 0;
          insere_fila_prontos(self, i);
        }
      }
      
      console_printf("SO: processo %d morto por segmentation fault", pid);
      return;
    }
    
    // Falta de página válida - trata
    console_printf("SO: falta de página %d do processo %d", pagina, pid);
    so_trata_falta_pagina(self, idx, pagina);
    
    // Incrementa contador de faltas
    self->tabela_processos[idx].n_faltas_pagina++;
    
    return;
  }
  
  // Outros erros - mata o processo
  console_printf("SO: erro fatal %s - matando processo %d", err_nome(err), pid);
  self->tabela_processos[idx].estado = MORTO;
  
  // Libera recursos
  if (self->tabela_processos[idx].swap_inicio >= 0) {
    swap_libera_processo(self->swap, pid);
  }
  mem_quadros_remove_processo(self->quadros, pid);
  if (self->tabela_processos[idx].tabpag != NULL) {
    tabpag_destroi(self->tabela_processos[idx].tabpag);
    self->tabela_processos[idx].tabpag = tabpag_cria();
  }

  // Desbloqueia processos esperando
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].estado == BLOQUEADO &&
        self->tabela_processos[i].esperando_pid == pid) {
      self->tabela_processos[i].estado = PRONTO;
      self->tabela_processos[i].esperando_pid = -1;
      self->tabela_processos[i].regA = 0;
      insere_fila_prontos(self, i);
    }
  }

  console_printf("SO: processo idx=%d pid=%d marcado como MORTO", idx, pid);
}


// ANTIGO

// static void so_trata_irq_err_cpu(so_t *self)
// {
//   console_printf("erro na CPU   ");
//   // Ocorreu um erro interno na CPU
//   // O erro está codificado em CPU_END_erro
//   // Em geral, causa a morte do processo que causou o erro
//   // Ainda não temos processos, causa a parada da CPU
//   // t2: com suporte a processos, deveria pegar o valor do registrador erro
//   //   no descritor do processo corrente, e reagir de acordo com esse erro
//   //   (em geral, matando o processo)
//   err_t err = self->tabela_processos[self->processo_corrente].regERRO;
//   console_printf("SO: IRQ não tratada -- erro na CPU: %s (%d)",
//                  err_nome(err), self->regComplemento);
//   console_printf("SO: IRQ não tratada -- erro na CPU: %s", err_nome(err));

//   self->erro_interno = true;
// }


// interrupção gerada quando o timer expira
static void so_trata_irq_relogio(so_t *self)
{
  console_printf("interrupção do relógio   ");
  // rearma o interruptor do relógio e reinicializa o timer para a próxima interrupção
  err_t e1, e2;
  e1 = es_escreve(self->es, D_RELOGIO_INTERRUPCAO, 0); // desliga o sinalizador de interrupção
  e2 = es_escreve(self->es, D_RELOGIO_TIMER, INTERVALO_INTERRUPCAO);
  if (e1 != ERR_OK || e2 != ERR_OK) {
    console_printf("SO: problema da reinicialização do timer");
    self->erro_interno = true;
  }
  
  // Envelhecimento LRU para o processo corrente
  if (self->processo_corrente >= 0 && self->processo_corrente < MAX_PROCESSOS) {
    processo *proc = &self->tabela_processos[self->processo_corrente];
    
    if (proc->estado == EXECUTANDO) {
      // Envelhecimento: desloca bits para direita e adiciona bit de acesso
      for (int pag = 0; pag < proc->n_paginas; pag++) {
        // Desloca para direita (divide por 2)
        proc->lru_counter[pag] >>= 1;
        
        // Adiciona bit de acesso no bit mais significativo
        if (tabpag_bit_acesso(proc->tabpag, pag)) {
          proc->lru_counter[pag] |= 0x80000000; // Seta bit mais significativo
          tabpag_zera_bit_acesso(proc->tabpag, pag); // Zera o bit de acesso
        }
      }
    }
  }
  
  // t2: deveria tratar a interrupção
  //   por exemplo, decrementa o quantum do processo corrente, quando se tem
  //   um escalonamento com quantum
  if (self->processo_corrente >= 0 && self->processo_corrente < MAX_PROCESSOS) {
    self->contador_quantum--;
    if (self->contador_quantum <= 0) {
      // Quantum esgotado, força troca de contexto
      console_printf("SO: quantum esgotado para processo %d", self->processo_corrente);
      self->tabela_processos[self->processo_corrente].estado = PRONTO;
      insere_fila_prontos(self, self->processo_corrente);
      self->processo_corrente = -1;  // força troca de processo
      return;
    }
  }
  console_printf("SO: interrupção do relógio (não tratada)");
}

static void so_trata_irq_desconhecida(so_t *self, int irq)
{
  console_printf("tratando IRQ desconhecida   ");
  console_printf("SO: não sei tratar IRQ %d (%s)", irq, irq_nome(irq));
  self->erro_interno = true;
}


// ---------------------------------------------------------------------
// CHAMADAS DE SISTEMA {{{1
// ---------------------------------------------------------------------

// funções auxiliares para cada chamada de sistema
static void so_chamada_le(so_t *self);
static void so_chamada_escr(so_t *self);
static void so_chamada_cria_proc(so_t *self);
static void so_chamada_mata_proc(so_t *self);
static void so_chamada_espera_proc(so_t *self);


static void so_trata_irq_chamada_sistema(so_t *self)
{
  console_printf("chamada de sistema   ");

  // a identificação da chamada está no registrador A
  // t2: com processos, o reg A deve estar no descritor do processo corrente

  if (self->processo_corrente < 0 || self->processo_corrente >= MAX_PROCESSOS) {
    console_printf("SO: processo_corrente inválido em chamada_sistema");
    self->erro_interno = true;
    return;
  }

  int id_chamada = self->tabela_processos[self->processo_corrente].regA;
  console_printf("SO: chamada de sistema %d", id_chamada);
  switch (id_chamada) {
    case SO_LE:
      so_chamada_le(self);
      break;
    case SO_ESCR:
      so_chamada_escr(self);
      break;
    case SO_CRIA_PROC:
      so_chamada_cria_proc(self);
      break;
    case SO_MATA_PROC:
      so_chamada_mata_proc(self);
      break;
    case SO_ESPERA_PROC:
      so_chamada_espera_proc(self);
      break;
    default:
      console_printf("SO: chamada de sistema desconhecida (%d)", id_chamada);
      // t2: deveria matar o processo
      self->erro_interno = true;
  }
}

static void so_chamada_le(so_t *self)
{
  console_printf("chamada de leitura   ");
  int terminal_teclado = self->tabela_processos[self->processo_corrente].terminal - 2; // D_TERM_X_TELA - 2 = D_TERM_X_TECLADO
  int terminal_teclado_ok = self->tabela_processos[self->processo_corrente].terminal - 1; // D_TERM_X_TELA - 1 = D_TERM_X_TECLADO_OK
  for (;;) {  // espera ocupada!
    int estado;
    if (es_le(self->es, terminal_teclado_ok, &estado) != ERR_OK) {
      console_printf("SO: problema no acesso ao estado do teclado");
      self->erro_interno = true;
      return;
    }
    if (estado != 0) break;
    console_tictac(self->console);
  }
  int dado;
  if (es_le(self->es, terminal_teclado, &dado) != ERR_OK) {
    console_printf("SO: problema no acesso ao teclado");
    self->erro_interno = true;
    return;
  }
  self->tabela_processos[self->processo_corrente].regA = dado;
}

// implementação da chamada se sistema SO_ESCR
// escreve o valor do reg X na saída corrente do processo
static void so_chamada_escr(so_t *self)
{
  console_printf("chamada de escrita   ");
  int terminal_tela_ok = self->tabela_processos[self->processo_corrente].terminal + 1; // D_TERM_X_TELA + 1 = D_TERM_X_TELA_OK
  for (;;) {
    int estado;
    if (es_le(self->es, terminal_tela_ok, &estado) != ERR_OK) {
      console_printf("SO: problema no acesso ao estado da tela");
      self->erro_interno = true;
      return;
    }
    if (estado != 0) break;
    console_tictac(self->console);
  }
  int dado;
  dado = self->tabela_processos[self->processo_corrente].regX;
  if (es_escreve(self->es, self->tabela_processos[self->processo_corrente].terminal, dado) != ERR_OK) {
    console_printf("SO: problema no acesso à tela");
    self->erro_interno = true;
    return;
  }
  self->tabela_processos[self->processo_corrente].regA = 0;
}

// implementação da chamada se sistema SO_CRIA_PROC
// cria um processo



// --- alteração em so_chamada_cria_proc: encontrar slot ANTES de carregar ---

//TESTE

static void so_chamada_cria_proc(so_t *self)
{
  console_printf("chamada de criação de processo   ");

  /* valida processo corrente */
  if (self->processo_corrente < 0 || self->processo_corrente >= MAX_PROCESSOS) {
    console_printf("SO: processo_corrente inválido em cria_proc\n");
    self->erro_interno = true;
    return;
  }

  /* obter endereço virtual (no regX do processo chamador) que aponta para o nome */
  int ender_proc = self->tabela_processos[self->processo_corrente].regX;
  char nome[100];

  /* copia string do espaço do processo chamador */
  if (!so_copia_str_do_processo(self, 100, nome, ender_proc,
                                self->processo_corrente)) {
    /* falha ao copiar: retorna erro para o chamador */
    self->tabela_processos[self->processo_corrente].regA = -1;
    return;
  }

  /* procura um slot livre na tabela de processos ANTES de carregar o programa */
  int slot = -1;
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].estado == MORTO) {
      slot = i;
      break;
    }
  }
  if (slot == -1) {
    /* sem slot disponível */
    self->tabela_processos[self->processo_corrente].regA = -1;
    return;
  }

  /* garante que a tabela de páginas do slot exista (so_cria normalmente já cria) */
  if (self->tabela_processos[slot].tabpag == NULL) {
    self->tabela_processos[slot].tabpag = tabpag_cria();
    if (self->tabela_processos[slot].tabpag == NULL) {
      console_printf("SO: não foi possível criar tabela de páginas para novo processo\n");
      self->tabela_processos[self->processo_corrente].regA = -1;
      return;
    }
  }

  /* carrega o programa no slot correto (so_carrega_programa usa 'processo' para decidir) */
  int ender_carga = so_carrega_programa(self, slot, nome);
  if (ender_carga <= 0) {
    /* falha na carga */
    self->tabela_processos[self->processo_corrente].regA = -1;
    return;
  }

  /* inicializa o novo processo no slot */
  static int next_pid = 2; /* init já é 1 */
  self->tabela_processos[slot].pid = next_pid++;
  self->tabela_processos[slot].ppid = self->tabela_processos[self->processo_corrente].pid;
  self->tabela_processos[slot].estado = PRONTO;
  self->tabela_processos[slot].regA = 0;
  self->tabela_processos[slot].regX = 0;
  self->tabela_processos[slot].regERRO = 0;
  self->tabela_processos[slot].regPC = ender_carga;
  self->tabela_processos[slot].quantum = self->quantum;  /* quantum inicial */
  self->tabela_processos[slot].esperando_pid = -1;
  self->tabela_processos[slot].esperando_dispositivo = -1;
  self->tabela_processos[slot].memoria_base = 0;
  self->tabela_processos[slot].memoria_limite = 0;
  self->tabela_processos[slot].prioridade = 0.0f;
  self->tabela_processos[slot].tempo_desbloqueio = 0;
  self->tabela_processos[slot].n_faltas_pagina = 0;

  /* associa terminal de forma determinística por PID (4 terminais disponíveis) */
  int term_idx = (self->tabela_processos[slot].pid - 1) % 4;
  self->tabela_processos[slot].terminal = D_TERM_A_TELA + term_idx * 4;

  /* inserir na fila de prontos */
  insere_fila_prontos(self, slot);

  /* retorna o PID do novo processo no regA do processo criador */
  self->tabela_processos[self->processo_corrente].regA = self->tabela_processos[slot].pid;

  console_printf("SO: processo criado slot=%d pid=%d pc=%d", slot,
                 self->tabela_processos[slot].pid, self->tabela_processos[slot].regPC);
}





//ANTIGO
// static void so_chamada_cria_proc(so_t *self)
// {
//   console_printf("chamada de criação de processo   ");
//   int ender_proc = self->tabela_processos[self->processo_corrente].regX;
//   char nome[100];
//   if (!so_copia_str_do_processo(self, 100, nome, ender_proc,
//                                 self->processo_corrente)) {
//     self->tabela_processos[self->processo_corrente].regA = -1;
//     return;
//   }

//   // Procura slot livre (MORTO ou nunca usado) ANTES de carregar o programa
//   int slot = -1;
//   for (int i = 0; i < MAX_PROCESSOS; i++) {
//     if (self->tabela_processos[i].estado == MORTO) {
//       slot = i;
//       break;
//     }
//   }
//   if (slot == -1) {
//     self->tabela_processos[self->processo_corrente].regA = -1;
//     return;
//   }

//   // Inicializa campo quadro_livre do novo slot a partir do quadro_livre atual
//   // (simples heurística para continuar alocação sequencial como no t2)
//   self->tabela_processos[slot].quadro_livre = 0;

//   // Carrega o programa no slot apropriado (agora PASSAMOS 'slot' como processo)
//   int ender_carga = so_carrega_programa(self, slot, nome);
//   if (ender_carga <= 0) {
//     self->tabela_processos[self->processo_corrente].regA = -1;
//     return;
//   }

//   // Inicializa novo processo (preenche campos após carga bem sucedida)
//   static int next_pid = 2; // init é 1
//   self->tabela_processos[slot].pid = next_pid++;
//   self->tabela_processos[slot].ppid = self->tabela_processos[self->processo_corrente].pid;
//   self->tabela_processos[slot].estado = PRONTO;
//   self->tabela_processos[slot].regA = 0;
//   self->tabela_processos[slot].regX = 0;
//   self->tabela_processos[slot].regERRO = 0;
//   self->tabela_processos[slot].regPC = ender_carga;
//   self->tabela_processos[slot].quantum = self->quantum;  // inicializa com quantum completo
//   self->tabela_processos[slot].esperando_pid = -1;
//   self->tabela_processos[slot].esperando_dispositivo = -1;
//   self->tabela_processos[slot].memoria_base = 0;
//   self->tabela_processos[slot].memoria_limite = 0;
//   self->tabela_processos[slot].prioridade = 0.0f;  // prioridade inicial máxima

//   insere_fila_prontos(self, slot);

//   // Retorna o PID do novo processo no regA do processo criador
//   self->tabela_processos[self->processo_corrente].regA = self->tabela_processos[slot].pid;

//   self->tabela_processos[slot].terminal = D_TERM_A_TELA + ( (self->tabela_processos[slot].pid-1) % 4 )*4; // Associa terminal baseado no slot








  




// // static void so_chamada_cria_proc(so_t *self)
// // {
// //   console_printf("chamada de criação de processo   ");
// //   int ender_proc = self->tabela_processos[self->processo_corrente].regX;
// //   char nome[100];
// //   if (!so_copia_str_do_processo(self, 100, nome, ender_proc,
// //                                 self->processo_corrente)) {
// //     self->tabela_processos[self->processo_corrente].regA = -1;
// //     return;
// //   }

// //   int ender_carga = so_carrega_programa(self, self->processo_corrente, nome);
// //   if (ender_carga <= 0) {
// //     self->tabela_processos[self->processo_corrente].regA = -1;
// //     return;
// //   }

// //   // Procura slot livre (MORTO ou nunca usado)
// //   int slot = -1;
// //   for (int i = 0; i < MAX_PROCESSOS; i++) {
// //     if (self->tabela_processos[i].estado == MORTO) {
// //       slot = i;
// //       break;
// //     }
// //   }
// //   if (slot == -1) {
// //     self->tabela_processos[self->processo_corrente].regA = -1;
// //     return;
// //   }

//   // // Inicializa novo processo
//   // static int next_pid = 2; // init é 1
//   // self->tabela_processos[slot].pid = next_pid++;
//   // self->tabela_processos[slot].ppid = self->tabela_processos[self->processo_corrente].pid;
//   // self->tabela_processos[slot].estado = PRONTO;
//   // self->tabela_processos[slot].regA = 0;
//   // self->tabela_processos[slot].regX = 0;
//   // self->tabela_processos[slot].regERRO = 0;
//   // self->tabela_processos[slot].regPC = ender_carga;
//   // self->tabela_processos[slot].quantum = self->quantum;  // inicializa com quantum completo
//   // self->tabela_processos[slot].esperando_pid = -1;
//   // self->tabela_processos[slot].esperando_dispositivo = -1;
//   // self->tabela_processos[slot].memoria_base = 0;
//   // self->tabela_processos[slot].memoria_limite = 0;
//   // self->tabela_processos[slot].prioridade = 0.0f;  // prioridade inicial máxima

//   // insere_fila_prontos(self, slot);

//   // // Retorna o PID do novo processo no regA do processo criador
//   // self->tabela_processos[self->processo_corrente].regA = self->tabela_processos[slot].pid;

//   // self->tabela_processos[slot].terminal = D_TERM_A_TELA + (self->tabela_processos[slot].pid-1%4)*4; // Associa terminal baseado no slot

//   // if(i == 0) self->tabela_processos[i].terminal = D_TERM_A_TELA;
//   self->tabela_processos[self->processo_corrente].estado = BLOQUEADO;
//   self->tabela_processos[self->processo_corrente].esperando_pid = self->tabela_processos[slot].pid;


// }

// implementação da chamada se sistema SO_MATA_PROC
// mata o processo com pid X (ou o processo corrente se X é 0)
static void so_chamada_mata_proc(so_t *self)
{
  console_printf("chamada de morte de processo   ");
  int pid_alvo = self->tabela_processos[self->processo_corrente].regX;
  int alvo = -1;
  if (pid_alvo == 0) {
    alvo = self->processo_corrente;
  } else {
    for (int i = 0; i < MAX_PROCESSOS; i++) {
      if (self->tabela_processos[i].pid == pid_alvo && self->tabela_processos[i].estado != MORTO) {
        alvo = i;
        break;
      }
    }
  }
  if (alvo == -1) {
    self->tabela_processos[self->processo_corrente].regA = -1;
    return;
  }
  self->tabela_processos[alvo].estado = MORTO;
  self->tabela_processos[alvo].regA = -1;
  // Desbloqueia o pai se estiver esperando esse filho
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].estado == BLOQUEADO && self->tabela_processos[i].esperando_pid == self->tabela_processos[alvo].pid) {
      self->tabela_processos[i].estado = PRONTO;
      self->tabela_processos[i].esperando_pid = -1;
      self->tabela_processos[i].regA = 0; // sucesso
    }
  }
  self->tabela_processos[self->processo_corrente].regA = 0;
}

// implementação da chamada se sistema SO_ESPERA_PROC
// espera o fim do processo com pid X
static void so_chamada_espera_proc(so_t *self)
{
  console_printf("chamada de espera de processo   ");
  int pid_esperado = self->tabela_processos[self->processo_corrente].regX;
  int existe = 0;
  for (int i = 0; i < MAX_PROCESSOS; i++) {
    if (self->tabela_processos[i].pid == pid_esperado && self->tabela_processos[i].estado != MORTO) {
      existe = 1;
      break;
    }
  }
  if (!existe) {
    self->tabela_processos[self->processo_corrente].regA = -1;
    return;
  }
  self->tabela_processos[self->processo_corrente].estado = BLOQUEADO;
  self->tabela_processos[self->processo_corrente].esperando_pid = pid_esperado;
}

// ---------------------------------------------------------------------
// GERENCIAMENTO DE MEMÓRIA VIRTUAL {{{1
// ---------------------------------------------------------------------

// Aloca um quadro livre da memória principal
// Retorna o número do quadro ou -1 se não houver quadro livre
static int so_aloca_quadro(so_t *self)
{
    int quadro = mem_quadros_tem_livre(self->quadros);
    if (quadro >= 0) {
        console_printf("SO: quadro %d alocado (livre)", quadro);
        return quadro;
    }
    
    // Não há quadro livre - precisa substituir uma página
    console_printf("SO: sem quadros livres - iniciando substituição");
    
    // Escolhe vítima usando algoritmo FIFO (implementado em memoria_quadros)
    quadro = mem_quadros_libera_quadro_fifo(self->quadros);
    
    if (quadro < 0) {
        console_printf("SO: erro ao liberar quadro");
        return -1;
    }
    
    // Obtém informações sobre a página que está sendo removida
    int dono_pid = mem_quadros_pega_dono(self->quadros, quadro);
    int pagina_vitima = mem_quadros_pega_pagina(self->quadros, quadro);
    
    console_printf("SO: substituindo quadro %d (proc=%d pag=%d)", 
                   quadro, dono_pid, pagina_vitima);
    
    // Encontra o processo dono
    int idx_dono = -1;
    for (int i = 0; i < MAX_PROCESSOS; i++) {
        if (self->tabela_processos[i].pid == dono_pid && 
            self->tabela_processos[i].estado != MORTO) {
            idx_dono = i;
            break;
        }
    }
    
    if (idx_dono < 0) {
        console_printf("SO: processo dono %d não encontrado", dono_pid);
        return quadro; // Retorna o quadro mesmo assim
    }
    
    // Verifica se a página foi alterada
    bool alterada = tabpag_bit_alteracao(self->tabela_processos[idx_dono].tabpag, pagina_vitima);
    
    if (alterada) {
        // Precisa escrever a página na swap antes de remover
        console_printf("SO: página %d do processo %d foi alterada - escrevendo na swap",
                       pagina_vitima, dono_pid);
        
        int end_fis = quadro * TAM_PAGINA;
        int dados[TAM_PAGINA];
        
        // Lê dados do quadro
        for (int i = 0; i < TAM_PAGINA; i++) {
            mem_le(self->mem, end_fis + i, &dados[i]);
        }
        
        // Escreve na swap
        int end_swap = swap_endereco_pagina(self->swap, dono_pid, pagina_vitima);
        int tempo_bloqueio;
        
        if (swap_escreve_pagina(self->swap, end_swap, dados, TAM_PAGINA, &tempo_bloqueio) != ERR_OK) {
            console_printf("SO: erro ao escrever página na swap");
        }
        
        // Bloqueia o processo dono se ele estiver executando
        if (idx_dono == self->processo_corrente) {
            self->tabela_processos[idx_dono].tempo_desbloqueio = tempo_bloqueio;
            self->tabela_processos[idx_dono].estado = BLOQUEADO;
            console_printf("SO: processo %d bloqueado até %d por escrita em disco",
                           dono_pid, tempo_bloqueio);
        }
    }
    
    // Invalida a página na tabela do processo dono
    tabpag_invalida_pagina(self->tabela_processos[idx_dono].tabpag, pagina_vitima);
    
    console_printf("SO: quadro %d liberado", quadro);
    return quadro;
}

// Trata uma falta de página
static void so_trata_falta_pagina(so_t *self, int idx_proc, int pagina)
{
    console_printf("SO: tratando falta de página %d do processo idx=%d",
                   pagina, idx_proc);
    
    processo *proc = &self->tabela_processos[idx_proc];
    
    // Aloca um quadro
    int quadro = so_aloca_quadro(self);
    if (quadro < 0) {
        console_printf("SO: erro ao alocar quadro para falta de página");
        self->erro_interno = true;
        return;
    }
    
    // Lê a página da swap
    int end_swap = swap_endereco_pagina(self->swap, proc->pid, pagina);
    if (end_swap < 0) {
        console_printf("SO: erro ao obter endereço da página na swap");
        self->erro_interno = true;
        return;
    }
    
    int dados[TAM_PAGINA];
    int tempo_bloqueio;
    
    if (swap_le_pagina(self->swap, end_swap, dados, TAM_PAGINA, &tempo_bloqueio) != ERR_OK) {
        console_printf("SO: erro ao ler página da swap");
        self->erro_interno = true;
        return;
    }
    
    // Escreve dados no quadro
    int end_fis = quadro * TAM_PAGINA;
    for (int i = 0; i < TAM_PAGINA; i++) {
        mem_escreve(self->mem, end_fis + i, dados[i]);
    }
    
    // Atualiza tabela de páginas
    tabpag_define_quadro(proc->tabpag, pagina, quadro);
    
    // Registra o quadro como ocupado
    mem_quadros_muda_estado(self->quadros, quadro, false, proc->pid, pagina);
    
    // Bloqueia o processo pelo tempo de I/O
    proc->tempo_desbloqueio = tempo_bloqueio;
    proc->estado = BLOQUEADO;
    
    console_printf("SO: página %d mapeada no quadro %d, processo bloqueado até %d",
                   pagina, quadro, tempo_bloqueio);
}

// ---------------------------------------------------------------------
// CARGA DE PROGRAMA {{{1
// ---------------------------------------------------------------------

// funções auxiliares
static int so_carrega_programa_na_memoria_fisica(so_t *self, programa_t *programa);
static int so_carrega_programa_na_memoria_virtual(so_t *self,
                                                  programa_t *programa,
                                                  int processo);

// carrega o programa na memória
// se processo for NENHUM_PROCESSO, carrega o programa na memória física
//   senão, carrega na memória virtual do processo
// retorna o endereço de carga ou -1
static int so_carrega_programa(so_t *self, int processo,
                               char *nome_do_executavel)
{
  console_printf("SO: carga de '%s'", nome_do_executavel);

  programa_t *programa = prog_cria(nome_do_executavel);
  if (programa == NULL) {
    console_printf("Erro na leitura do programa '%s'\n", nome_do_executavel);
    return -1;
  }

  int end_carga;
  if (processo == NENHUM_PROCESSO) {
    end_carga = so_carrega_programa_na_memoria_fisica(self, programa);
  } else {
    end_carga = so_carrega_programa_na_memoria_virtual(self, programa, processo);
  }


  prog_destroi(programa);
  return end_carga;
}

static int so_carrega_programa_na_memoria_fisica(so_t *self, programa_t *programa)
{
  int end_ini = prog_end_carga(programa);
  int end_fim = end_ini + prog_tamanho(programa);

  for (int end = end_ini; end < end_fim; end++) {
    if (mem_escreve(self->mem, end, prog_dado(programa, end)) != ERR_OK) {
      console_printf("Erro na carga da memória, endereco %d\n", end);
      return -1;
    }
  }

  console_printf("SO: carga na memória física %d-%d\n", end_ini, end_fim);
  return end_ini;
}

static int so_carrega_programa_na_memoria_virtual(so_t *self,
                                                  programa_t *programa,
                                                  int processo)
{
  // t3: Implementação com paginação sob demanda
  // Carrega o programa inteiro na memória secundária (swap)
  // Não aloca nenhum quadro de memória principal
  // As páginas serão trazidas para memória principal por demanda (falta de página)
  
  if (processo < 0 || processo >= MAX_PROCESSOS) {
    console_printf("SO: processo inválido %d", processo);
    return -1;
  }
  
  int end_virt_ini = prog_end_carga(programa);
  
  // O código só funciona se o programa iniciar no início de uma página
  if ((end_virt_ini % TAM_PAGINA) != 0) {
    console_printf("SO: programa deve iniciar no início de uma página");
    return -1;
  }
  
  int end_virt_fim = end_virt_ini + prog_tamanho(programa) - 1;
  int pagina_ini = end_virt_ini / TAM_PAGINA;
  int pagina_fim = end_virt_fim / TAM_PAGINA;
  int n_paginas = pagina_fim - pagina_ini + 1;
  
  console_printf("SO: carregando programa proc=%d end_virt=%d-%d n_pag=%d",
                 processo, end_virt_ini, end_virt_fim, n_paginas);
  
  // Aloca espaço na swap para todas as páginas do processo
  int swap_inicio = swap_aloca(self->swap, n_paginas, self->tabela_processos[processo].pid);
  if (swap_inicio < 0) {
    console_printf("SO: erro ao alocar espaço na swap");
    return -1;
  }
  
  // Salva informações no processo
  self->tabela_processos[processo].swap_inicio = swap_inicio;
  self->tabela_processos[processo].n_paginas = n_paginas;
  
  // Carrega cada página do programa na swap
  for (int pag = 0; pag < n_paginas; pag++) {
    int dados[TAM_PAGINA];
    
    // Inicializa com zeros
    for (int i = 0; i < TAM_PAGINA; i++) {
      dados[i] = 0;
    }
    
    // Copia dados do programa para o buffer
    int end_virt_pag_ini = (pagina_ini + pag) * TAM_PAGINA;
    int end_virt_pag_fim = end_virt_pag_ini + TAM_PAGINA - 1;
    
    for (int end_virt = end_virt_pag_ini; end_virt <= end_virt_pag_fim; end_virt++) {
      if (end_virt >= end_virt_ini && end_virt <= end_virt_fim) {
        dados[end_virt - end_virt_pag_ini] = prog_dado(programa, end_virt);
      }
    }
    
    // Escreve a página na swap
    int end_swap = swap_inicio + pag;
    int tempo_bloqueio;
    
    if (swap_escreve_pagina(self->swap, end_swap, dados, TAM_PAGINA, &tempo_bloqueio) != ERR_OK) {
      console_printf("SO: erro ao escrever página %d na swap", pag);
      return -1;
    }
    
    console_printf("SO: página %d carregada na swap[%d]", pag, end_swap);
  }
  
  // NÃO mapeia nenhuma página na tabela de páginas
  // As páginas serão mapeadas sob demanda quando houver falta de página
  console_printf("SO: programa carregado na swap, %d páginas, paginação sob demanda", n_paginas);
  
  return end_virt_ini;
}



// ---------------------------------------------------------------------
// ACESSO À MEMÓRIA DOS PROCESSOS {{{1
// ---------------------------------------------------------------------

// copia uma string da memória do processo para o vetor str.
// retorna false se erro (string maior que vetor, valor não char na memória,
//   erro de acesso à memória)
// O endereço é um endereço virtual de um processo.
// t3: Com memória virtual, cada valor do espaço de endereçamento do processo
//   pode estar em memória principal ou secundária (e tem que achar onde)
static bool so_copia_str_do_processo(so_t *self, int tam, char str[tam],
                                     int end_virt, int processo)
{
  if (self->tabela_processos[processo].estado == MORTO) return false;
  
  // Configura a MMU com a tabela de páginas do processo
  if (processo != self->processo_corrente) {
    // Salva tabela atual e configura a do processo desejado
    mmu_define_tabpag(self->mmu, self->tabela_processos[processo].tabpag);
  }
  
  for (int indice_str = 0; indice_str < tam; indice_str++) {
    int caractere;
    // Lê da memória virtual do processo
    err_t err = mmu_le(self->mmu, end_virt + indice_str, &caractere, usuario);
    
    // Se houver falta de página, trata
    if (err == ERR_PAG_AUSENTE) {
      int pagina = (end_virt + indice_str) / TAM_PAGINA;
      console_printf("SO: falta de página em copia_str (pag=%d)", pagina);
      so_trata_falta_pagina(self, processo, pagina);
      
      // Tenta ler novamente
      err = mmu_le(self->mmu, end_virt + indice_str, &caractere, usuario);
    }
    
    if (err != ERR_OK) {
      // Restaura tabela de páginas anterior se necessário
      if (processo != self->processo_corrente) {
        mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
      }
      return false;
    }
    
    if (caractere < 0 || caractere > 255) {
      // Restaura tabela de páginas anterior se necessário
      if (processo != self->processo_corrente) {
        mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
      }
      return false;
    }
    
    str[indice_str] = caractere;
    if (caractere == 0) {
      // Restaura tabela de páginas anterior se necessário
      if (processo != self->processo_corrente) {
        mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
      }
      return true;
    }
  }
  
  // Restaura tabela de páginas anterior se necessário
  if (processo != self->processo_corrente) {
    mmu_define_tabpag(self->mmu, self->tabela_processos[self->processo_corrente].tabpag);
  }
  
  // estourou o tamanho de str
  return false;
}


static void insere_fila_prontos(so_t *self, int idx_processo) {
    self->fila_prontos[self->fim_fila] = idx_processo;
    self->fim_fila = (self->fim_fila + 1) % MAX_PROCESSOS;
}
 
static int remove_fila_prontos(so_t *self) {
    if (self->inicio_fila == self->fim_fila) {
        return -1; // fila vazia
    }
    int idx = self->fila_prontos[self->inicio_fila];
    self->inicio_fila = (self->inicio_fila + 1) % MAX_PROCESSOS;
    return idx;
}




void so_define_escalonador(so_t *self, int id)
{
    if (id == 2) {
        self->escalonador = so_escalona2;
        console_printf("SO: usando escalonador 2 (prioridade)");
    } else {
        self->escalonador = so_escalona;
        console_printf("SO: usando escalonador 1 (round-robin)");
    }
}

// vim: foldmethod=marker
